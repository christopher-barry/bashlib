# -*- mode: sh; -*-
# Library: various data structure functions
# Dependencies: base.cfg, macros, logging, utilities
# Author: Christopher Barry
# License: GPLv2 or later
#
################################################################################
#       D  A  T  A     S  T  R  U  C  T  U  R  E     L  I  B  R  A  R  Y       #
################################################################################

# um, yeah, so none of this does anything yet. stop back later. possibly much.

#-------------------------------------------------------------------------------
function typedef()
# Description: creates/deletes a structured data record type definition
# Depends: bashlib,
# API:
# switches: <-C|--create type_name> <record_type:record_name[:validator_funcname]> ...
#           <-D|--delete type_name>
#     $1 - type name
#     $@ - record <type>:<name>[:validator] list, where: (in create mode only)
#         <type> is one of:
#            'A' for associative_array
#            'a' for indexed_array
#            'b' for boolean
#            'f' for float number
#            'h' for hex number
#            'i' for integer number
#            's' for string
#     and <name> is an [[:word:]]+ name for the record.
#     if [:validator] is present, making the parameter a colon
#     separated triplet, then 'validator' is the name of an existing
#     function that will be used to validate the information when it
#     is assigned to 'name' with the:
#         'rec <recname> set <-[isb]> <name> <value>' or
#         'rec <recname> set <-[aA]> <name> <<index|+>|key> <value>'
#     command. 'validator' must take <name> as it's only parameter and
#     return true or false.
# Inputs:
# Outputs:
# Environment:
#  BASHLIB_STRUCT_BASE == the base directory for struct data and template storage
# Returns:
#  0 on success
#  1 on failure
# Examples:
#  define a type of structure:
#   typedef --create hotel_room i:rmnum:valid_rmnum \
#               s:telnum:valid_telnum a:bednum:valid_bednum \
#               A:beds:valid_beds b:occupied A:occupant:valid_occupant
#  this creates a struct 'template', saving it to:
#    ${_rundir_}/${_struct_typedir_}/${1}
#    or, in plain English, something like:
#    /run/user/$USER/my_script_name/26674360-fbdb-4f2f-83cd-73779a67c4b0/struct/type/hotel_room
#    putting the data in the tmpfs filesystem for better performance.
#
#  the 'new()' function, defined elsewhere in this file, creates
#  instances of data structures defined with 'struct()'.
#
#-
{
    local _params_="${@}"
    func-init

    local -a _lo=( --create --delete )
    local -a _so=( -C -D )
    local -a _the_opts=$( $(convert_long_options _lo _so "${_params_}") )

    while getopts :CD OPT "${_the_opts[@]}"; do
        case $OPT in
            C) ACTION=create ;;
            D) ACTION=delete ;;
        esac
    done
    shift $(( OPTIND - 1 ))
    OPTIND=1

    local _struct_name_=${1}; shift
    is_word ${_struct_name_} || { _rtn=1 E="bad struct name '${_struct_name_}', may only contain letter, number and '_' characters"; error-f; }
    local _struct_dir=${_rundir_}/${STRUCT_TYPEDIR}/${_struct_name_}

    case ${ACTION} in

        create)
            # create the struct location
            is_exist_dir ${_struct_dir} && { _rtn=1 E="struct '${_struct_name_}' already exists."; error-f; }
            mkdir -p ${_struct_dir}
            echo ${_struct_name_} >${_struct_dir}/.struct_type

            # create the struct layout
            (
                cd ${_struct_dir}
                local p=
                for p in "${@}"; do
                    # create a temporary array of ('type' 'name' 'validator') from each record spec parameter
                    local -a _tnv=()
                    readarry _tnv <(echo -en "${p//:/\\n}")
                    (( ${#_tnv[@]} > 1 )) && (( ${#_tnv[@]} < 4 )) || { _rtn=1 E="invalid record defnition: '${p}'"; error-f; }
                    is_word ${_tnv[1]} || { _rtn=1 E="bad record name '${_tnv[1]}', may only contain letter, number and '_' characters"; error-f; }
                    is_exist_dir ${_tnv[1]} && { _rtn=1 E="record '${_tnv[1]}' already exists."; error-f; }
                    mkdir -p ${_struct_dir}/${_tnv[1]}
                    (
                        cd ${_tnv[1]}
                        echo "${_tnv[1]}" >${_tnv[1]}_name

                        case ${_tnv[0]} in
                            A)
                                echo "associative_array" >${_tnv[1]}_type
                                echo "is_hash" >${_tnv[1]}_validator
                                ;;
                            a)
                                echo "indexed_array" >${_tnv[1]}_type
                                echo "is_array" >${_tnv[1]}_validator
                                ;;
                            b)
                                echo "bool" >${_tnv[1]}_type
                                echo "is_bool" >${_tnv[1]}_validator
                                ;;
                            f)
                                echo "float" >${_tnv[1]}_type
                                echo "is_float" >${_tnv[1]}_validator
                                ;;
                            h)
                                echo "hex" >${_tnv[1]}_type
                                echo "is_hex" >${_tnv[1]}_validator
                                ;;
                            i)
                                echo "integer" >${_tnv[1]}_type
                                echo "is_decimal" >${_tnv[1]}_validator
                                ;;
                            s)
                                echo "string" >${_tnv[1]}_type
                                echo "is_string" >${_tnv[1]}_validator
                                ;;
                            *)
                                _rtn=1 E="invalid type specification '${_tnv[0]}'"
                                error-f
                                ;;
                        esac

                        # if an optional custom validator function is assigned, add it to standard validator
                        (( ${#_tnv[@]} == 3 )) && {
                            is_function ${_tnv[2]} || { _rtn=1 E="validator function '${_tnv[2]}' is not defined."; error-f; }
                            echo "${_tnv[2]}" >>${_tnv[1]}_validator
                        } || :
                    )
                done
            )
            ;;

        delete)
            [[ -d ${_struct_dir} ]] && rm -rf ${_struct_dir}
            ;;
    esac

    func-return
}
##------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
function new()
# Description: instantiates a new instance of an object
# Depends: bashlib,
# API:
#  $1   - object type
#  $2   - object type_name
#  $3   - instance name
# Inputs:
# Outputs:
# Environment:
# Returns:
#  0 on success
#  1 on failure
# Examples:
#  new struct my_struct_type my_struct_name
#-
{
    local _params_="${@}"
    func-init

    local _obj_=${1}
    local _type_=${2}
    local _name_=${3}

    case ${_obj_} in

        struct)
            local _struct_dir=${_rundir_}/${STRUCT_TYPEDIR}
            local _data_dir=${_rundir_}/${STRUCT_DATADIR}

            is_exist_dir ${_struct_dir}/${_type_} || { _rtn=1 E="struct typedef '${_type_}' does not exist."; error-f; }
            is_exist_dir ${_data_dir}/${_name_} && { _rtn=1 E="struct instance '${_name_}' already exists."; error-f; }

            (
                cd ${_struct_dir}
                local tmpname=${RANDOM}-${RANDOM}-${RANDOM}
                cp -r ${_type_} ${_data_dir}/${tmpname}
                mv ${_data_dir}/${tmpname} ${_data_dir}/${_name_}
            )
            ;;
        *)
            _rtn=1 E="unknown object type"; error-f
            ;;
    esac

    func-return
}
##------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
function _get()
# Description: gets data from a struct node
# Depends: bashlib,
# API:
#  $1 - name
#  $@ - <regex>
# Inputs:
# Outputs:
# Environment:
# Returns:
#  0 on success
#  1 on failure
# Examples:
#  v=$(_get ${n})
#-
{
    local _params_="${@}"
    func-init

    # function body

    func-return
}
##------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
function _set()
# Description: set data into a struct node
# Depends: bashlib,
# API:
#  $1 - name
#  $@ - key 'value'
# Inputs:
# Outputs:
# Environment:
# Returns:
#  0 on success
#  1 on failure
# Examples:
#  _put ${n} ${k} ${v}
#-
{
    local _params_="${@}"
    func-init

    # function body

    func-return
}
##------------------------------------------------------------------------------
