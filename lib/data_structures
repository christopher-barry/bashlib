# -*- mode: sh; -*-
# Library: various data structure functions
# Dependencies: base.cfg, macros, logging, utilities
# Author: Christopher Barry
# License: GPLv2 or later
#
################################################################################
#       D  A  T  A     S  T  R  U  C  T  U  R  E     L  I  B  R  A  R  Y       #
################################################################################

# um, yeah, so none of this does anything yet. stop back later. possibly much.

#-------------------------------------------------------------------------------
function typedef()
# Description: creates/deletes a structured data record type definition
# Depends: bashlib,
# API:
# switches: <-c|--create type_name> [-i|--inherit existing_type_name]  <record_type:record_name[:validator_funcname]> ...
#           <-d|--delete type_name>
#     $1 - type name
#     $@ - record <type>:<name>[:validator] list, where: (in create mode only)
#         <type> is one of:
#            'A' for associative_array
#            'a' for indexed_array
#            'b' for boolean
#            'f' for floating point number
#            'h' for hex number
#            'i' for integer number
#            's' for string
#     and <name> is an [_[:alnum:]]+ conformant name for the record.
#
#     if [:validator] is present, which is an [_[:alnum:]]+ conformant
#     name, making the parameter a colon separated triplet, then
#     'validator' is the name of an existing function that will be
#     used to validate the information when it is assigned to 'name'
#     with:
#
#      '_set struct <structure_name> <record_name> <value>' for type=[bfhis], or
#      '_set struct <structure_name> <record_name> <<index|+>|key> <value>' for [Aa] types.
#
#     'validator' functions must take <value> as their only parameter and
#     return true or false only, with no output.
# Inputs:
# Outputs:
# Environment:
#   see session macros
# Returns:
#  0 on success
#  1 on failure
# Examples:
#  define a type of structure:
#   typedef --create hotel_room i:rmnum:valid_rmnum \
#               s:telnum:valid_telnum a:bednum:valid_bednum \
#               A:beds:valid_beds b:occupied A:occupant:valid_occupant
#  this creates a struct 'template', saving it to:
#    ${_structdir_}/${_struct_name_}
#    or, in plain English, something like:
#    /run/user/$USER/my_script_name/26674360-fbdb-4f2f-83cd-73779a67c4b0/typedefs/type/hotel_room
#    putting the data in the tmpfs filesystem for better performance.
#
#  the 'new()' function, defined elsewhere in this file, creates
#  instances of data structures defined with 'typedef()'.
#
#-
{
    local _params_="${@}"
    func-init
    verify_argc $# 3 $# || { _rtn=1 E="${_err} ${FUNCNAME}: invalid argument count"; error-f; }

    local -a _lo=( --create --inherit --delete )
    local -a _so=(  -c       -i       -d )
    local -a _the_opts=( $(convert_long_options _lo _so "${_params_}") )

    set -- "${_the_opts[@]}"
    while getopts :c:d:i: OPT "${@}"; do
        case $OPT in
            c) local __action__=create __structname__=${OPTARG} ;;
            i) local __inherit__=${OPTARG} ;;
            d) local __action__=delete __structname__=${OPTARG} ;;
        esac
    done
    shift $(( OPTIND - 1 ))
    OPTIND=1

    local _struct_name_=${__structname__}; shift

    is_word ${_struct_name_} || { _rtn=1 E="bad struct name '${_struct_name_}', may only contain letter, number and '_' characters"; error-f; }
    local _struct=${_structdefs_}/${_struct_name_}

    case ${__action__} in

        create)
            # create the struct location
            [[ "${__inherit__}" ]] && {
                is_exist_dir ${_structdefs_}/${__inherit__} && {
                    local _inherited=${_structdefs_}/${__inherit__}
                } || {
                    _rtn=1 E="inherited struct '${__inherit__}' not found in ${_structdefs_}/."; error-f;
                }
                (
                    cd ${_structdefs_}
                    cp -r ${__inherit__} ${_struct_name_}
                )
            } || {
                is_exist_dir ${_struct} && { _rtn=1 E="struct '${_struct}' already exists."; error-f; }
                mkdir -p ${_struct}
            }
            echo ${_struct_name_} >${_struct}/.struct_type

            # create the struct layout
            (
                cd ${_struct}
                local p=
                for p in "${@}"; do
                    # create a temporary array of ('type' 'name' 'validator') from each record spec parameter
                    local -a _tnv=( ${p//:/ } )
                    (( ${#_tnv[@]} > 1 )) && (( ${#_tnv[@]} < 4 )) || { _rtn=1 E="invalid record defnition: '${p}'"; error-f; }
                    is_word ${_tnv[1]} || { _rtn=1 E="bad record name '${_tnv[1]}', may only contain letter, number and '_' characters"; error-f; }
                    is_exist_dir ${_tnv[1]} && { _rtn=1 E="record '${_tnv[1]}' already exists."; error-f; }
                    mkdir -p ${_struct}/${_tnv[1]}
                    (
                        cd ${_tnv[1]}
                        echo "${_tnv[1]}" >${_tnv[1]}_name

                        case ${_tnv[0]} in
                            A)
                                echo "associative_array" >${_tnv[1]}_type
                                echo "is_struct_hash" >${_tnv[1]}_validator
                                ;;
                            a)
                                echo "indexed_array" >${_tnv[1]}_type
                                echo "is_struct_array" >${_tnv[1]}_validator
                                ;;
                            b)
                                echo "bool" >${_tnv[1]}_type
                                echo "is_bool" >${_tnv[1]}_validator
                                ;;
                            f)
                                echo "float" >${_tnv[1]}_type
                                echo "is_float" >${_tnv[1]}_validator
                                ;;
                            h)
                                echo "hex" >${_tnv[1]}_type
                                echo "is_hex" >${_tnv[1]}_validator
                                ;;
                            i)
                                echo "integer" >${_tnv[1]}_type
                                echo "is_decimal" >${_tnv[1]}_validator
                                ;;
                            s)
                                echo "string" >${_tnv[1]}_type
                                echo "is_string" >${_tnv[1]}_validator
                                ;;
                            *)
                                _rtn=1 E="invalid type specification '${_tnv[0]}'"
                                error-f
                                ;;
                        esac

                        # if an optional custom validator function is assigned, add it to standard validator
                        (( ${#_tnv[@]} == 3 )) && {
                            is_function ${_tnv[2]} || { _rtn=1 E="validator function '${_tnv[2]}' for record '${_tnv[1]}' is not defined."; error-f; }
                            echo "${_tnv[2]}" >>${_tnv[1]}_validator
                        } || :
                    )
                done
            )
            ;;

        delete)
            [[ -d ${_struct} ]] && rm -rf ${_struct}
            ;;
    esac

    func-return
}
##------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
function new()
# Description: instantiates a new instance of an object
# Depends: bashlib,
# API:
#  $1   - object type
#  $2   - object type_name
#  $3   - instance name
# Inputs:
# Outputs:
# Environment:
# Returns:
#  0 on success
#  1 on failure
# Examples:
#  new struct my_struct_type my_struct_name
#-
{
    local _params_="${@}"
    func-init
    verify_argc $# 3 || { _rtn=1 E="${_err} ${FUNCNAME}: invalid argument count"; error-f; }

    local _obj_=${1}
    local _type_=${2}
    local _name_=${3}

    case ${_obj_} in

        struct)
            local _struct_dir=${_rundir_}/${STRUCT_TYPEDIR}
            local _data_dir=${_rundir_}/${STRUCT_DATADIR}

            is_exist_dir ${_struct_dir}/${_type_} || { _rtn=1 E="struct typedef '${_type_}' does not exist."; error-f; }
            is_exist_dir ${_data_dir}/${_name_} && {
                _rtn=1 E="struct instance '${_name_}' already exists."; error-f;
            } || {
                mkdir -p ${_data_dir}/${_name_} || { _rtn=1 E="creating struct instance '${_name_}' failed."; error-f; }
            }

            (
                cd ${_struct_dir}/${_type_}
                cp -r * ${_data_dir}/${_name_} || { _rtn=1 E="instantiating '${_name_}' failed."; error-f; }
            )
            ;;
        *)
            _rtn=1 E="unknown object type"; error-f
            ;;
    esac

    func-return
}
##------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
function _set()
# Description: store data in a previously defined object with mulitple
#              type vlaidation mechanisms.
# Depends: bashlib,
# API:
#  $1 - object type
#  $2 - object name
#  $3 - object record_id
#  $@ - object record_id data
# Inputs:
# Outputs:
# Environment:
# Returns:
#  0 on success
#  1 on failure
# Examples:
#  _set ${t} ${n} ${r} "${rd[@]}"
#-
{
    local _params_="${@}"
    func-init
    verify_argc $# 4 || { _rtn=1 E="${_err} ${FUNCNAME}: invalid argument count"; error-f; }

    # function body

    func-return
}
##------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
function _get()
# Description: retrieve data from an existing object
# Depends: bashlib,
# API:
#  $1 - object type
#  $2 - object name
#  $3 - object record_id|<regex>
# Inputs:
# Outputs:
# Environment:
# Returns:
#  0 on success
#  1 on failure
# Examples:
#  v=$(_get ${n})
#-
{
    local _params_="${@}"
    func-init
    verify_argc $# 2 3 || { _rtn=1 E="${_err} ${FUNCNAME}: invalid argument count"; error-f; }

    # function body

    func-return
}
##------------------------------------------------------------------------------
