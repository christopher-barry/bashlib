# -*- mode: sh; -*-
# Library: various macro aliases
# Dependencies: base.cfg
# Author: Christopher Barry
# License: GPLv2 or later
# Depends: bashlib awk mkdir id rm

################################################################################
#       M  A  C  R  O     F  U  N  C  T  I  O  N     L  I  B  R  A  R  Y       #
################################################################################

# macros (aliases) behave like subroutines executed in the current
# scope. They also seriously reduce the boilerplate footprint in each
# function definition, and make global changes simpler. For standard
# function init and return/exit code, they can do things that using
# another function there just can't do. Their beauty is that they
# exist and execute in their containing function's scope, and don't
# define a new, nested scope of their own, yet you can nest them for
# reusability and structure, and still maintain a flat scope!  Sure,
# they can't accept parameters, but they can embed variable names that
# can actually reflect a local variable in the function they are
# executing in. They're nifty, useful, and I really like 'em.

# ...and you thought they were little more than: alias ll='ls -la'

# Their naming convention in bashlib is always hyphen-separated
# lowercase-words. This separates them easily in the codebase, and
# makes custom syntax highlighting routines work easier.

# this option allows aliases non-interactively.
shopt -s expand_aliases


: BEGIN MACRO DEFINITIONS

#---[ d e b u g ]-------------------------------------------------------

alias debug-get-state-prog='declare _dbgstate=$(log_debug_get_state); log_debug_control'

alias debug-set-state-prog='log_debug_set_state ${_dbgstate}'


alias debug-get-state-func='local _dbgstate=$(log_debug_get_state); log_debug_control'

alias debug-set-state-func='log_debug_set_state ${_dbgstate}'

##----------------------------------------------------------------------


#---[ d e f a u l t   m e s s a g e s ]---------------------------------

alias prog-init-messages='declare _err="Error:" _warn="Warning:" E="${_self_}: ${_params_} failed"'

alias prog-return-messages='get-return-status; E=${E:-"${_err} ${_self_}: ${_params_} failed"}'


alias func-init-messages='local _err="Error:" _warn="Warning:" E="${FUNCNAME}: ${_params_} failed"'

alias func-return-messages='get-return-status; E=${E:-"${_err} ${FUNCNAME}: ${_params_} failed"}'

##----------------------------------------------------------------------


#---[ t r a p s ]-------------------------------------------------------

alias prog-trap='trap "log_error \${_rtn:-\${?}} 1 \${E}" EXIT'


alias func-trap='trap "log_error \${_rtn:-\${?}} 1 \${E}" RETURN'

##----------------------------------------------------------------------


#---[ i n f o r m a t i o n ]-------------------------------------------

alias this-name='_this_=${FUNCNAME:-${0##*/}}; _this_=${_this_//[[:punct:]]/_}'

alias this-source='declare -g ${_this_^^}_DEFINED="${BASH_SOURCE:-${SCRIPT_SOURCE}}"'

alias this-line-number='declare -g ${_this_^^}_LINENO="${BASH_LINENO:-1}"'

alias this-invoked='declare -g ${_this_^^}_INVOKED="${BASH_SOURCE[1]:-${SCRIPT_SOURCE}}"'

# define func-named vars for each invoked function
alias this-info='this-name; this-source; this-line-number; this-invoked'

##----------------------------------------------------------------------


#---[ i n i t ]---------------------------------------------------------

#alias _-init-_=


#---[ s e s s i o n ]---------------------------------------------------

alias this-script-fullpath='SCRIPT_SOURCE="${0}"'

alias this-script-name='_self_="${0##*/}"'

# allow maintaining a known session id using WITH_SESSION, along with
# KEEP_RUNDIR to make data structures persistent across program
# invocations. e.g.:
#
#   export KEEP_RUNDIR=true WITH_SESSION=26674360-fbdb-4f2f-83cd-73779a67c4b0
#
# now, the data will not be deleted at program termination, and it will
# use the specified session directory. however, the session directory
# will go away by default at user logout or system reboot because it is
# on a volatile memory filesystem by default.
alias this-session='_session_=${WITH_SESSION:-$(gen_uuid)}'

alias this-rundir-init='mkdir -p ${_rundir_}'

# to modify _rundir_ to use a non-tmpfs filesystem path (to make any
# stored application data persistent across reboots), set WITH_RUNDIR
# to a non-volatile storage location. e.g.:
#
#   export WITH_RUNDIR=${HOME}/data
#
# the location must be writable by the user running the application.
#
alias this-rundir='_rundir_=${WITH_RUNDIR:-/run/user}/$(id -u)/${_self_}/${_session_}'

alias this-struct-root='_structdir_=${_rundir_}/struct'

alias this-struct-typedefs='_structdefs_=${_structdir_}/typedefs'

alias this-struct-data='_structdata_=${_structdir_}/data'

# init session for this instance
alias session-init='this-script-fullpath; this-script-name; this-session; this-rundir; this-rundir-init; this-struct-root; this-struct-typedefs; this-struct-data'

##----------------------------------------------------------------------


#---[ p r o g r a m ]---------------------------------------------------

# init header for programs
alias prog-init='debug-get-state-prog; this-info; prog-init-messages; prog-trap'

# composite on-error macro for programs
alias error-p='prog-return-messages; debug-set-state-prog; remove_macros; remove_rundir; exit ${_rtn}'

# exit footer for programs
alias prog-exit='error-p'

##----------------------------------------------------------------------


#---[ f u n c t i o n ]-------------------------------------------------

# init header macro for functions
alias func-init='debug-get-state-func; this-info; func-init-messages; func-trap'

# composite on-error macro for functions
alias error-f='func-return-messages; get-env-local; debug-set-state-func; return ${_rtn}'

# return footer macro for functions
alias func-return='error-f'

##----------------------------------------------------------------------


#---[ m i n i m a l   f u n c t i o n ]---------------------------------

# special case init header for simple functions
alias minimal-func-init='debug-get-state-func; this-info'

# special case return footer for simple functions
alias minimal-func-return='debug-set-state-func'

##----------------------------------------------------------------------


#---[ v a l u e   f u n c t i o n ]-------------------------------------

# special case init header for simple functions that need to return specific values
alias value-func-init='minimal-func-init; trap "log ${FUNCNAME} ${_params_} returned \${_rtn:-\${?}}" RETURN'

# special case footer for simple functions that need to return specific values
alias value-func-return='get-return-status; minimal-func-return; return ${_rtn}'

##----------------------------------------------------------------------


#---[ c o p r o c e s s   f u n c t i o n ]-----------------------------

# special case init header for coproc function: minimal, plus allows deleting an environemnt file on exit
alias coproc-func-init='minimal-func-init;'

# special case return footer for coproc functions: minimal plus clean up temp env files
alias coproc-func-return='[[ -f ${_source_env_fn} ]] && rm -f --preserve-root ${_source_env_fn}; minimal-func-return'

##----------------------------------------------------------------------


#---[ s t a t u s ]-----------------------------------------------------

# examine the last executed pipeline for error conditions
alias get-return-status='_rtn=$(get_status)'

##----------------------------------------------------------------------


#---[ e n v i r o n m e n t   d u m p i n g   t o o l s ]---------------

# dump alias names defined in the environment
alias get-env-alias-names='alias |  awk -F= "{ print \$1 }" | awk -F[[:blank:]] "{ print \$2 }"'

# dump indexed array names defined in the environment
alias get-env-array-names='declare -a | awk -F= "{ print \$1 }" | awk -F[[:blank:]] "{ print \$3 }"'

# dump exported names defined in the environment
alias get-env-exported-names='declare -x | awk -F= "{ print \$1 }" | awk -F[[:blank:]] "{ print \$3 }"'

# dump function names defined in the environment
alias get-env-function-names='declare -F | awk -F[[:blank:]] "{ print \$3 }"'

# dump associative array names defined in the environment
alias get-env-hash-names='declare -A | awk -F= "{ print \$1 }" | awk -F[[:blank:]] "{ print \$3 }"'

# dump integer names defined in the environment
alias get-env-integer-names='declare -i | awk -F= "{ print \$1 }" | awk -F[[:blank:]] "{ print \$3 }"'

# dump readonly names defined in the environment
alias get-env-readonly-names='declare -r | awk -F= "{ print \$1 }" | awk -F[[:blank:]] "{ print \$3 }"'

# dump regular var names defined in the environment
alias get-env-regular-names='declare -p | awk -F= "{ print \$1 }" | grep "^declare[[:blank:]][\-]\{2\}[[:blank:]].*$" | awk "{ print \$3 }"'

# generate an array of all set local variables
alias get-env-local='readarray _${FUNCNAME}_env < <(local|grep -v '^E=.*$')'

: END MACRO DEFINITIONS


# on every load of this file, automatically create an up-to-date array
# of all the alias names defined in this file, so they can be
# destroyed on the way out.
# this code must be after all the alias definitions
begin='begin macro defininitions'
end='end macro defininitions'
while read line; do
    [[ "${line}" =~ ${begin^^} ]] && state=start
    [[ "${line}" =~ ${end^^} ]]   && state=stop
    case ${state} in
        start)
            state=started
            ;;
        started)
            [[ ! "${line}" =~ ((^\#.*$)|(^$)) ]] && [[ "${line}" =~ ^alias.*$ ]] && {
                MACRO_NAMES+=( $(echo "${line}" | awk '{print $2}' | awk -F= '{print $1}') )
            }
            ;;
        stop)
            break
            ;;
    esac
done < <( egrep -v '^\#.*$|^$' $(ipath macros) )

begin= end= state= line=

# called to cleanup from error-p, and prog-exit macro definitions
function remove_macros() { shopt -u expand_aliases; unalias ${MACRO_NAMES[@]} &>/dev/null; }

# called to remove unique temp work area
function remove_rundir() { (( KEEP_RUNDIR )) || { [[ -d ${_rundir_} ]] &&  rm --preserve-root -rf ${_rundir_}; }; }
